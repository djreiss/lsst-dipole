
somewhere else, do:
```
git clone https://github.com/lsst/ip_diffim.git
cd ip_diffim
source ~/lsstsw/setup.csh
#setup -t b1813 ip_diffim
#setup -k -r .
setup -t 1813 -r .
scons
```

then you will want to add `$HOME/lsstsw/miniconda/lib/python2.7/site-packages` to your `PYTHONPATH` in order to be able to import `joblib` and friends.

now edit and run the code in here.


```python
import sys
from collections import namedtuple

import numpy as np

%matplotlib inline
#%matplotlib notebook
import matplotlib.pyplot as plt

import matplotlib
matplotlib.style.use('ggplot')

import seaborn as sns
sns.set(style="whitegrid", palette="pastel", color_codes=True)

import lmfit

from joblib import Parallel, delayed  
import multiprocessing

np.random.seed(666)

import pandas as pd
class sizeme():
    """ Class to change html fontsize of object's representation"""
    def __init__(self,ob, size=50, height=120):
        self.ob = ob
        self.size = size
        self.height = height
    def _repr_html_(self):
        repl_tuple = (self.size, self.height, self.ob._repr_html_())
        return u'<span style="font-size:{0}%; line-height:{1}%">{2}</span>'.format(*repl_tuple)
```


```python
## LSST imports:
import lsst.utils.tests as tests
import lsst.daf.base as dafBase
#import lsst.afw.display.ds9 as ds9
import lsst.afw.image as afwImage
import lsst.afw.geom as afwGeom
import lsst.afw.table as afwTable
import lsst.afw.math as afwMath
import lsst.meas.algorithms as measAlg
import lsst.ip.diffim as ipDiffim
```


```python
def singleGaussian2d(x, y, xc, yc, sigma_x=1., sigma_y=1., theta=0., offset=0.):
    cos_theta2, sin_theta2 = np.cos(theta)**2., np.sin(theta)**2.
    sigma_x2, sigma_y2 = sigma_x**2., sigma_y**2.
    a = cos_theta2/(2.*sigma_x2) + sin_theta2/(2.*sigma_y2)
    b = -(np.sin(2.*theta))/(4.*sigma_x2) + (np.sin(2.*theta))/(4.*sigma_y2)
    c = sin_theta2/(2.*sigma_x2) + cos_theta2/(2.*sigma_y2)
    xxc, yyc = x-xc, y-yc
    out = np.exp( - (a*(xxc**2.) + 2.*b*xxc*yyc + c*(yyc**2.)))
    if offset != 0.:
        out += offset
    return out

verbose = False    # BAD !!!

def generateNoiseImage(z, bg=1.): ##, verbose=True):
    global verbose     # BAD !!!
    if verbose: 
        npix = np.prod(z.shape)
        print 'SNR:', z.sum(), bg, npix*bg, z.sum() / np.sqrt(z.sum() + 2.*(bg*npix))
    return np.random.poisson(z+bg, z.shape)

def generateStarImage(x, flux, xcen, ycen, psfWidth, sigma2=None, ampl2=0.1, afw=False, noise=0.):
    """
    Stellar thumbnail based on 2-d (potentially [TBD] ellipsoidal) double-gaussian: 
    generateStarImage(x, flux, xcen, ycen, psfWidth, sigma2=None, ampl2=0.1, afw=False, noise=0.)
    """
    if sigma2 is None:
        sigma2 = psfWidth * 1.75
        
    if afw:
        ## Wow - this is about 3x slower than the below (pure python)...
        generator = afwMath.DoubleGaussianFunction2D(psfWidth, sigma2, ampl2)
        x1 = x[0] - xcen
        x2 = x[1] - ycen
        zout = np.array([generator(x1[i], x1[i]) for i in xrange(len(x1))])
        zout *= flux

    else: ## don't have stack installed, use a custom double gaussian2d generator. This is faster!
#      * double Guassian (sum of two Gaussians)
#      *
#      * Intended for use as a PSF model: the main Gaussian represents the core
#      * and the second Gaussian represents the wings.
#      *
#      * f(x,y) = A (e^(-r^2 / 2 sigma1^2) + ampl2 e^(-r^2 / 2 sigma2^2))
#      * where:
#      * * A = 1 / (2 pi (sigma1^2 + ampl2 sigma2^2))
#      * * r^2 = x^2 + y^2
#      * coefficients c[0] = sigma1, c[1] = sigma2, c[2] = ampl2
#       def doubleGaussian2d(x, y, xc, yc, sigma1=1., sigma2=1., ampl2=0.1):
#           out = (multFac / (sigma1Sq + (b * sigma2Sq))) *
#              (np.exp(-radSq / (2.0 * sigma1Sq)) + 
#              (b * np.exp(-radSq / (2.0 * sigma2Sq)))));
        def singleGaussian2d(x, y, xc, yc, sigma_x=1., sigma_y=1., theta=0., offset=0.):
            cos_theta2, sin_theta2 = np.cos(theta)**2., np.sin(theta)**2.
            sigma_x2, sigma_y2 = sigma_x**2., sigma_y**2.
            a = cos_theta2/(2.*sigma_x2) + sin_theta2/(2.*sigma_y2)
            b = -(np.sin(2.*theta))/(4.*sigma_x2) + (np.sin(2.*theta))/(4.*sigma_y2)
            c = sin_theta2/(2.*sigma_x2) + cos_theta2/(2.*sigma_y2)
            xxc, yyc = x-xc, y-yc
            out = np.exp( - (a*(xxc**2.) + 2.*b*xxc*yyc + c*(yyc**2.)))
            if offset != 0.:
                out += offset
            return out

        sigma1 = psfWidth
        tmp1 = singleGaussian2d(x[0], x[1], xcen, ycen, sigma1, sigma1)
        tmp2 = singleGaussian2d(x[0], x[1], xcen, ycen, sigma2, sigma2)
        ampl1 = 1.0 / (2. * np.pi) / (sigma1**2. + ampl2 * sigma2**2.)
        zout = flux * ampl1 * (tmp1 + tmp2 * ampl2)
        
    if noise != 0.:
        zout = generateNoiseImage(zout, bg=noise**2.)

    return zout

## Note right now we are only fitting one flux value and the 4 positions, not
##   anything related to the shape of the PSF!
def dipoleFunc(x, flux, xcenPos, ycenPos, xcenNeg, ycenNeg, psfWidth, fluxNeg=None, sigma2=None, ampl2=0.1, afw=False, noise=0.):
    """
    Dipole based on 2-d (potentially [TBD] ellipsoidal) double-gaussian: 
    dipoleFunc(x, flux, xcenPos, ycenPos, xcenNeg, ycenNeg) #, sig1, sig2)
    """
    if fluxNeg is None:
        fluxNeg = flux
        
    zoutPos = generateStarImage(x, flux,    xcenPos, ycenPos, psfWidth, sigma2=sigma2, ampl2=ampl2, afw=afw, noise=noise)
    zoutNeg = generateStarImage(x, fluxNeg, xcenNeg, ycenNeg, psfWidth, sigma2=sigma2, ampl2=ampl2, afw=afw, noise=noise)
    zout = zoutPos - zoutNeg
    zout = np.append([zout], [zoutPos, zoutNeg], axis=0)
    return zout

def genDipole(w=100, h=100, xc=50., yc=50., psfWidth=2., separation=2., rotAngle=0.0, flux=3000., noise=1., display=False):
    y, x = np.mgrid[:w, :h]
    x = x.ravel()
    y = y.ravel()
    in_x = [x, y]

    #z = np.array([generator(in_x[0][i] - xc, in_x[1][i] - yc) for i in np.arange(len(in_x[0]))])
    #z *= ht / z.max()
    rotAngRad = rotAngle / 180. * np.pi
    sep = separation / 2.
    z = dipoleFunc(in_x, flux=flux, xcenPos=xc+sep*np.cos(rotAngRad), ycenPos=yc+sep*np.sin(rotAngRad), 
                   xcenNeg=xc-sep*np.cos(rotAngRad), ycenNeg=yc-sep*np.sin(rotAngRad), psfWidth=psfWidth, noise=noise)
    ## DONE: accurate (poisson) noise proportional to pixel intensity. Now inside generateNoiseImage()
    #z += np.random.normal(0., noise+np.sqrt(np.abs(z)), x.shape) #* (0.1 + np.sqrt(np.abs(z)))
    if display:
        #zptp = z.ptp() / 2.
        plt.figure(figsize=(8, 2.5))
        plt.subplot(1, 3, 1)
        plt.imshow(z.reshape(3, w, h)[0,:], origin='lower', interpolation='none', cmap='gray' )#, vmin=-zptp, vmax=zptp)
        plt.title("Data")

    return x.reshape(w, h), y.reshape(w, h), z.reshape(3, w, h)
```


```python
## Convert to afw image.
def getDipoleExposure(z, psfWidth=2.):
    w, h = z.shape
    image = afwImage.MaskedImageF(w,h)
    image.set(0)
    array = image.getImage().getArray()
    array[:,:] = z
    # Set variance to 1.0 -- TODO, should set variance after adding flux
    var   = image.getVariance().getArray()
    ##var.set(noise)
    var[:,:] = np.abs(z)

    exposure = afwImage.makeExposure(image)
    
    # Create Psf for dipole measurement. Need a psf object too (for source detection below)
    psfSize = int(psfWidth * 20.) + 1
    psf = measAlg.DoubleGaussianPsf(psfSize, psfSize, psfWidth, psfWidth*1.75, 0.1) ## 2.0, 3.5, 0.1)
    psfim = psf.computeImage().convertF()
    psfim /= np.sum(psfim.getArray())
    exposure.setPsf(psf)
    
    return exposure

def detectDipoleSources(z, psfWidth, noise=1., detectSigma=5.0, grow=1, verbose=False, display=False):
    # Detect positive and negative sources in the image. 
    # See meas_algorithms/python/lsst/meas/algorithms/detection.py (SourceDetectionConfig) for config params
    exposure = getDipoleExposure(z, psfWidth=psfWidth)
    w, h = exposure.getWidth(), exposure.getHeight()
    
    config = measAlg.SourceDetectionConfig()
    config.thresholdPolarity = "both"
    config.reEstimateBackground = True
    config.nSigmaToGrow = psfWidth
    config.thresholdValue = detectSigma ##5.0   ## how do we set the detection threshold? Default is 5 sigma, set via config.thresholdValue
    schema = afwTable.SourceTable.makeMinimalSchema()  
    task = measAlg.SourceDetectionTask(schema, config=config)
    table = afwTable.SourceTable.make(schema)
    results = task.makeSourceCatalog(table, exposure, sigma=psfWidth)
#     if display:
#         ds9.mtv(image, frame=4, title="Detection plane")
        
    #if verbose: print len(results.sources)

    if display:
        plt.figure(figsize=(8, 2.5))
        plt.subplot(1, 3, 1)
        
        img_arr, mask_arr, var_arr = exposure.getMaskedImage().getArrays()
        plt.title("Original image")
        plt.imshow(img_arr, origin='lower', vmin=img_arr.min(), vmax=img_arr.max(), cmap='gray', extent=(0,w-1,0,h-1), interpolation='none')

        ## first overlay the pos and neg fp centers on the input image and show it.
        for fp in results.fpSets.positive.getFootprints():
            for pk in fp.getPeaks():
                plt.plot(pk.getIx(), pk.getIy(), 'rx')
        for fp in results.fpSets.negative.getFootprints():
            for pk in fp.getPeaks():
                plt.plot(pk.getIx(), pk.getIy(), 'bx')
    
    # Merge them together
    assert(len(results.sources) >= 2)
    fpSet = results.fpSets.positive
    fpSet.merge(results.fpSets.negative, grow, grow, False) ## note used to be tGrow=0, rGrow=0, but sometimes sources were not merged.
    sources = afwTable.SourceCatalog(table)
    fpSet.makeSources(sources)
    assert(len(sources) >= 1)
    
    s = sources[0]
    if verbose:
        print 'N SOURCES:', len(sources)
        for ss in sources: 
            print len(ss.getFootprint().getPeaks())
            if len(ss.getFootprint().getPeaks()) == 2:
                s = ss
            for pk in ss.getFootprint().getPeaks():
                print 'FOOTPRINT CENTER:', pk.getIy(), pk.getIx()
    
    assert(len(s.getFootprint().getPeaks()) == 2)

    if verbose:
        for pk in s.getFootprint().getPeaks():
            print 'FINAL FOOTPRINT CENTER:', pk.getIy(), pk.getIx()

    if display:
        #plt.figure(figsize=(8, 2.5))
        plt.subplot(1, 3, 2)
        
        img_arr, mask_arr, var_arr = exposure.getMaskedImage().getArrays()
        plt.title("Original image")
        plt.imshow(img_arr, origin='lower', vmin=img_arr.min(), vmax=img_arr.max(), cmap='gray', extent=(0,w-1,0,h-1), interpolation='none')
        #plt.plot(xp, yp, 'bx')
        #plt.plot(xn, yn, 'bx')

        ## first overlay the fp centers on the input image and show it.
        for pk in s.getFootprint().getPeaks():
            plt.plot(pk.getIx(), pk.getIy(), 'rx')

        plt.subplot(1, 3, 3)
        img_arr, mask_arr, var_arr = exposure.getMaskedImage().getArrays()
        plt.title("Detection plane")
        plt.imshow(mask_arr, origin='lower', vmin=-100, vmax=100, cmap='gray', extent=(0,w-1,0,h-1), interpolation='none')
        for pk in s.getFootprint().getPeaks():
            plt.plot(pk.getIx(), pk.getIy(), 'rx')
        
    return s
```


```python
def fitDipole(z, psfWidth=2., cenPos=None, cenNeg=None, tol=1e-3, rel_weight=0.1, verbose=False, display=False):
    """fitDipole(z, psfWidth=2., verbose=False, display=False, cenPos=None, cenNeg=None))
        Starting centroids may be provided as tuple/array coordinates of centroids of positive and negative lobes.
        If these are None, then assume they are the max/min of the stamp.
    """
    w, h = z[0,:].shape

    ## TBD: if this actually is what we end up using, then we can't sum over the entier image. Need to use a localized region.
    startingFlux = (z[1,:] - np.median(z[1,:])).sum()   ## remove the background

    ## For close/faint dipoles the starting locs (min/max) might be way off, let's help them a bit:
    centroidRange = psfWidth * 3.
    if cenPos is None:
        cenPos = np.array(np.unravel_index(np.argmax(z[1,:]), (w,h)))
        
    ## Note - this may be a cheat to assume the dipole is centered in center of the stamp.
    if np.sum(np.sqrt((np.array(cenPos) - np.array([w/2, h/2]))**2.)) > centroidRange:
        cenPos = np.array([w/2., h/2.])
    if cenNeg is None:
        cenNeg = np.array(np.unravel_index(np.argmin(z), (w,h)))
    if np.sum(np.sqrt((np.array(cenNeg) - np.array([w/2, h/2]))**2.)) > centroidRange:
        cenNeg = np.array([w/2., h/2.])

    gmod = lmfit.Model(dipoleFunc, verbose=verbose)

    ## parameter hints/constraints: https://lmfit.github.io/lmfit-py/model.html#model-param-hints-section
    gmod.set_param_hint('xcenPos', value=cenPos[0], min=cenPos[0]-centroidRange, max=cenPos[0]+centroidRange)
    gmod.set_param_hint('ycenPos', value=cenPos[1], min=cenPos[1]-centroidRange, max=cenPos[1]+centroidRange)
    gmod.set_param_hint('xcenNeg', value=cenNeg[0], min=cenNeg[0]-centroidRange, max=cenNeg[0]+centroidRange)
    gmod.set_param_hint('ycenNeg', value=cenNeg[1], min=cenNeg[1]-centroidRange, max=cenNeg[1]+centroidRange)
    gmod.set_param_hint('flux', value=startingFlux, min=0.1, max=startingFlux * 2.)  ## TBD: higher flux limit? 
    gmod.set_param_hint('fluxNeg', value=startingFlux, min=0.1, max=startingFlux * 2.)  ## TBD: higher flux limit? 
    
    ## Fixed parameters (dont fit for them):
    gmod.set_param_hint('psfWidth', value=psfWidth, vary=False)
    gmod.set_param_hint('sigma2', value=psfWidth * 1.75, vary=False)
    gmod.set_param_hint('ampl2', value=0.1, vary=False)
    gmod.set_param_hint('noise', value=0., vary=False)

    y, x = np.mgrid[:w, :h]
    z = np.array([z[0,:].ravel(), z[1,:].ravel(), z[2,:].ravel()])
    x = x.ravel()
    y = y.ravel()
    in_x = [x, y]
    
    lz = len(z[0,:])
    ## TBD: weight the data by 1/variance
    # weights = 1.0/np.sqrt(np.abs(z))+1.0
    ## Weight the "pre-subtraction" planes by rel_weight (relative to the actual diffim plane)
    weights = np.array([np.repeat(1., lz), np.repeat(rel_weight, lz), np.repeat(rel_weight, lz)])
        
    result = gmod.fit(z, weights=weights,
                      x=in_x, flux=startingFlux, fluxNeg=startingFlux, 
                      xcenPos=cenPos[0], ycenPos=cenPos[1], 
                      xcenNeg=cenNeg[0], ycenNeg=cenNeg[1], verbose=verbose, #) #, sig1=1., sig2=2.)
                      ## default fit method -- levenberg-marquardt ('leastsq')
                      fit_kws={'ftol':tol, 'xtol':tol, 'gtol':tol})  
                      #method='nelder',
                      #fit_kws={'tol':tol})
    
    if verbose: 
        print result.fit_report(show_correl=False) 
        ## This is how to get confidence intervals out, see here: https://lmfit.github.io/lmfit-py/confidence.html and 
        ##    here: http://cars9.uchicago.edu/software/python/lmfit/model.html
        ## Note this calc takes a long time (longer than the fit!)
        print result.ci_report()

    if display:
        plt.figure(figsize=(8, 2.5))
        plt.subplot(1, 3, 2)
        plt.imshow(result.best_fit.reshape(3, w, h)[0,:], origin='lower', interpolation='none', cmap='gray')
        plt.title("Model")
        plt.subplot(1, 3, 3)
        plt.imshow(z.reshape(3, w, h)[0,:] - result.best_fit.reshape(3, w, h)[0,:], origin='lower', cmap='gray', interpolation='none')
        plt.title("Residual")
        
    return result

def genDipoleAndFitIt(z=None, w=100, h=100, xc=50., yc=50., psfWidth=2., separation=2., rotAngle=0., flux=100., 
                        noise=1., rel_weight=0.1, sCat=None, verbose=False, display=False, return_fitObj=False):
    from collections import namedtuple
    resultsOutput = namedtuple('resultsOutput', 
        'inputCentroidX inputCentroidY inputSeparation inputRotation inputFlux inputPosCentroidX inputPosCentroidY inputNegCentroidX inputNegCentroidY psfFitPosCentroidX psfFitPosCentroidY psfFitNegCentroidX psfFitNegCentroidY psfFitPosFlux psfFitNegFlux psfFitCentroidX psfFitCentroidY psfFitOrientation psfFitSignaltoNoise')

    if z is None:
        _, _, z = genDipole(w=w, h=h, xc=xc, yc=yc, psfWidth=psfWidth, separation=separation, rotAngle=rotAngle,
                        flux=flux, noise=noise, display=display)
    
    pk1 = pk2 = None
    if sCat is None:
        try:
            sCat = detectDipoleSources(z[0,:], psfWidth=psfWidth, noise=noise, verbose=verbose, display=display)
            pks = sCat.getFootprint().getPeaks()
            pk1 = pks[0].getF() #)[::-1]  ## need to switch x,y ?? No.
            pk2 = pks[1].getF() #)[::-1]
        except AssertionError:  ## Unlike the ip_diffim code, this can still run. But to be fair, just return NA.
            #print 'HERE', flux, separation
            #pass
            out = resultsOutput(xc, yc, separation, rotAngle, flux, np.nan, np.nan, np.nan, np.nan,
                                np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.inf)
            return out

    #print separation, flux, np.abs(z).sum()
    result = fitDipole(z, psfWidth=psfWidth, cenPos=pk1, cenNeg=pk2, rel_weight=rel_weight, 
                       verbose=verbose, display=display)

    rotAngRad = rotAngle / 180. * np.pi
    xp, yp = xc + separation/2. * np.cos(rotAngRad), yc + separation/2. * np.sin(rotAngRad)
    xn, yn = xc - separation/2. * np.cos(rotAngRad), yc - separation/2. * np.sin(rotAngRad)
    results = result.best_values
    
    centroid = ((results['xcenPos']+results['xcenNeg'])/2., (results['ycenPos']+results['ycenNeg'])/2.)
    dx, dy = results['xcenPos']-results['xcenNeg'], results['ycenPos']-results['ycenNeg']
    angle = np.arctan2(dy, dx) / np.pi * 180.

    fluxVal, fluxErr = result.params['flux'].value, result.params['flux'].stderr
    fluxValNeg, fluxErrNeg = result.params['fluxNeg'].value, result.params['fluxNeg'].stderr
    signalToNoise = np.sqrt((fluxVal/fluxErr)**2 + (fluxValNeg/fluxErrNeg)**2) ## This is from DipoleAnalysis code
        
    out = resultsOutput(xc, yc, separation, rotAngle, flux, xp, yp, xn, yn, 
                        results['xcenPos'], results['ycenPos'], results['xcenNeg'], results['ycenNeg'],
                        fluxVal, -fluxValNeg, centroid[0], centroid[1], angle, signalToNoise)

    if not return_fitObj: return out #.best_values
    else: return out, result
```


```python
## I think this is the meat of the ip_diffim code that runs the measurement. 
def measureDipole(s, exposure, dipoleCentroid):
    msConfig = ipDiffim.DipoleMeasurementConfig()
    schema = afwTable.SourceTable.makeMinimalSchema()
    schema.addField("centroid_x", type=float)
    schema.addField("centroid_y", type=float)
    schema.addField("centroid_flag", type='Flag')
    task = ipDiffim.DipoleMeasurementTask(schema, config=msConfig)
    measCat = afwTable.SourceCatalog(schema)
    measCat.defineCentroid("centroid")
    source = measCat.addNew()
    source.set("centroid_x", dipoleCentroid[0])
    source.set("centroid_y", dipoleCentroid[1])
    source.setFootprint(s.getFootprint())

    #print 'DIPOLE: ', source.get("classification_dipole") ## from ipDiffim.DipoleMeasurementTask._ClassificationFlag
    # Then run the default SFM task.  Results not checked
    task.run(measCat, exposure)
    return measCat[0] 

def genDipoleAndFitIt_ipDiffim(z=None, w=100, h=100, xc=50., yc=50., psfWidth=2., separation=2., rotAngle=0., flux=100., 
                        noise=1., sCat=None, verbose=False, display=False):
    from collections import namedtuple
    resultsOutput = namedtuple('resultsOutput', 
        'inputCentroidX inputCentroidY inputSeparation inputRotation inputFlux inputPosCentroidX inputPosCentroidY inputNegCentroidX inputNegCentroidY psfFitPosCentroidX psfFitPosCentroidY psfFitNegCentroidX psfFitNegCentroidY psfFitPosFlux psfFitNegFlux psfFitCentroidX psfFitCentroidY psfFitOrientation psfFitSignaltoNoise')

    if z is None:
        _, _, z = genDipole(w=w, h=h, xc=xc, yc=yc, psfWidth=psfWidth, separation=separation, rotAngle=rotAngle,
                        flux=flux, noise=noise, display=display)
    
    pk1 = pk2 = (xc, yc)
    if sCat is None:
        try:
            sCat = detectDipoleSources(z[0,:], psfWidth=psfWidth, noise=noise, verbose=verbose, display=display)
            pks = sCat.getFootprint().getPeaks()
            pk1 = pks[0].getF() #)[::-1]  ## need to switch x,y ?? No.
            pk2 = pks[1].getF() #)[::-1]
        except AssertionError:  ## This fitting won't work unless there's a valid source catalog. If not, return NA.
            #print 'HERE', flux, separation
            #pass
            out = resultsOutput(xc, yc, separation, rotAngle, flux, np.nan, np.nan, np.nan, np.nan,
                                np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.inf)
            return out

    dipoleCentroid = (np.int(np.mean([pk1[0], pk2[0]])), np.int(np.mean([pk1[1], pk2[1]])))
    #print dipoleCentroid
    exposure = getDipoleExposure(z[0,:], psfWidth=psfWidth)
    result = measureDipole(sCat, exposure, dipoleCentroid=dipoleCentroid)
    #return result[0]
    
    ## provides (S/N, position, orientation) of measured dipoles
    dpAnalysis = ipDiffim.DipoleAnalysis()
    sn, centroid, orientation = dpAnalysis(result)

    rotAngRad = rotAngle / 180. * np.pi
    xp, yp = xc + separation/2. * np.cos(rotAngRad), yc + separation/2. * np.sin(rotAngRad)
    xn, yn = xc - separation/2. * np.cos(rotAngRad), yc - separation/2. * np.sin(rotAngRad)

    out = resultsOutput(xc, yc, separation, rotAngle, flux, xp, yp, xn, yn, 
        result.get("ip_diffim_PsfDipoleFlux_pos_centroid_x"), result.get("ip_diffim_PsfDipoleFlux_pos_centroid_y"),
        result.get("ip_diffim_PsfDipoleFlux_neg_centroid_x"), result.get("ip_diffim_PsfDipoleFlux_neg_centroid_y"),
        result.get("ip_diffim_PsfDipoleFlux_pos_flux"), result.get("ip_diffim_PsfDipoleFlux_neg_flux"),
        centroid.getX(), centroid.getY(), orientation, sn)
    return out
```


```python
verbose = True
x, y, z = genDipole(w=51, h=51, xc=25., yc=25., psfWidth=2., separation=2., rotAngle=324., 
                flux=2500., noise=1., display=True)
verbose = False
```

    SNR: 2500.0 1.0 2601.0 28.4864448168
    SNR: 2500.0 1.0 2601.0 28.4864448168



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_7_1.png)



```python
s = detectDipoleSources(z[0,:], psfWidth=2., noise=1., verbose=True, display=True)
#for pk in s.getFootprint().getPeaks():
#    print 'FOOTPRINT CENTER:', pk.getIy(), pk.getIx()
    
maxPos = np.array(np.unravel_index(np.argmax(z[1,:]), (51,51)))
minPos = np.array(np.unravel_index(np.argmin(z[2,:]), (51,51)))
print minPos, maxPos

tmp = s.getFootprint().getPeaks()[0].getF()
print tmp[0], tmp[1]
print np.array(tmp)[::-1]

tmp = s.getFootprint().getPeaks()[1].getF()
print tmp[0], tmp[1]
```

    N SOURCES: 1
    2
    FOOTPRINT CENTER: 23 27
    FOOTPRINT CENTER: 26 22
    FINAL FOOTPRINT CENTER: 23 27
    FINAL FOOTPRINT CENTER: 26 22
    [0 3] [25 26]
    27.0 23.0
    [ 23.  27.]
    22.0 26.0



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_8_1.png)



```python
%timeit fitDipole(z, psfWidth=2., verbose=False, display=False)
result = fitDipole(z, psfWidth=2., rel_weight=0.1, verbose=True, display=True)
```

    10 loops, best of 3: 40.1 ms per loop
     - Adding parameter for hint "xcenPos"
     - Adding parameter for hint "ycenPos"
     - Adding parameter for hint "xcenNeg"
     - Adding parameter for hint "ycenNeg"
     - Adding parameter for hint "flux"
     - Adding parameter for hint "fluxNeg"
     - Adding parameter for hint "psfWidth"
     - Adding parameter for hint "sigma2"
     - Adding parameter for hint "ampl2"
     - Adding parameter for hint "noise"
     - Adding parameter "flux"
     - Adding parameter "xcenPos"
     - Adding parameter "ycenPos"
     - Adding parameter "xcenNeg"
     - Adding parameter "ycenNeg"
     - Adding parameter "psfWidth"
     - Adding parameter "ampl2"
     - Adding parameter "noise"
     - Adding parameter "fluxNeg"
     - Adding parameter "sigma2"
    [[Model]]
        Model(dipoleFunc)
    [[Fit Statistics]]
        # function evals   = 87
        # data points      = 7803
        # variables        = 6
        chi-square         = 10463.100
        reduced chi-square = 1.342
    [[Variables]]
        xcenPos:    25.7956803 +/- 0.022319 (0.09%) (init= 25)
        ycenPos:    24.4297061 +/- 0.018981 (0.08%) (init= 26)
        xcenNeg:    24.2077884 +/- 0.022989 (0.09%) (init= 24)
        ycenNeg:    25.3167101 +/- 0.019537 (0.08%) (init= 23)
        flux:       2844.87556 +/- 60.11464 (2.11%) (init= 2518)
        fluxNeg:    2766.45290 +/- 60.07338 (2.17%) (init= 2518)
        psfWidth:   2 (fixed)
        sigma2:     3.5 (fixed)
        ampl2:      0.1 (fixed)
        noise:      0 (fixed)
    
                99.70%    95.00%    67.40%    _BEST_    67.40%    95.00%    99.70%
     xcenPos:  -0.06245  -0.04145  -0.02259  25.79568  +0.01908  +0.03934  +0.06032
     ycenPos:  -0.05409  -0.03534  -0.01705  24.42971  +0.02050  +0.03926  +0.05872
     xcenNeg:  -0.06039  -0.03904  -0.01679  24.20779  +0.02629  +0.04666  +0.06776
     ycenNeg:  -0.05861  -0.03950  -0.01981  25.31671  +0.01797  +0.03759  +0.05734
     flux   :-148.53472 -95.34673 -43.595672844.87557 +66.61862+120.11838+176.37800
     fluxNeg:-148.62030 -95.51898 -43.881462766.45291 +66.20682+119.63391+175.82983



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_9_1.png)


OK, I see that measureDipole is slow because of the psf fitting - in `DipoleAlgorithms.cc`. It seems to take nearly 1s for some fits (especially for closely-separated dipoles).

UPDATE - after compiling with O3, the dipole fitting is ~60ms now!

Why is it slow? Possible reasons:

1. `PsfDipoleFlux::chi2()` computes the PSF *image* (pos. and neg.) to compute the model, rather than using something like `afwMath.DoubleGaussianFunction2D()` as I do above. Or if that is not possible (may need to use a pixelated input PSF) then speed up the computation of the dipole model image (right now it uses multiple vectorized function calls).
2. It spends a lot of time floating around near the minimum and perhaps can be cut off more quickly (note this could be caused by (1.)
3. Perhaps its starting parameters (derived from the naive coordinates) could be made more accurate. At least it looks like the starting flux values are being set way too low (looks like +/- 22.0, should be ~3000 -- how is that being set?)
4. it computes chi2 over the entire subimage (confirm this?) rather than the inner 2,3,4, or 5 sigma of the PSF (or even better within the source's footprint(s)
5. some calculations are computed each time during minimization (in chi2 function) that can be moved outside (not sure if these calc's are really expensive though)
6. (FIXED) no constraints on the parameters (e.g. pos. flux > 0; neg. flux < 0; centroids, etc.)

Need to check out -- maybe because dipole fit is so slow, it's not enabled in the main pipelines, thus it uses the naive method by default which is inaccurate.

Note: It seems that the dipole fit is a lot faster for dipoles of greater separation than for those that are closer (it seems the optimization [minuit]) takes longer to converge).

But for now, let's just test the algorithm and worry about timing later.


```python
result = genDipoleAndFitIt(z=z, w=51, h=51, xc=25., yc=25., psfWidth=2., separation=2., rotAngle=0.,
                              flux=2500., noise=1., rel_weight=0.1, verbose=False, display=False)
print result

%timeit genDipoleAndFitIt(z=z, w=51, h=51, xc=25., yc=25., psfWidth=2., separation=2., rotAngle=0., \
                              flux=2500., noise=1., rel_weight=0.1, verbose=False, display=False)
```

    resultsOutput(inputCentroidX=25.0, inputCentroidY=25.0, inputSeparation=2.0, inputRotation=0.0, inputFlux=2500.0, inputPosCentroidX=26.0, inputPosCentroidY=25.0, inputNegCentroidX=24.0, inputNegCentroidY=25.0, psfFitPosCentroidX=25.788448912619, psfFitPosCentroidY=24.434035512066107, psfFitNegCentroidX=24.217002564504224, psfFitNegCentroidY=25.313316455582292, psfFitPosFlux=2867.6791663414192, psfFitNegFlux=-2789.1115136725502, psfFitCentroidX=25.002725738561612, psfFitCentroidY=24.873675983824199, psfFitOrientation=-29.22858775123888, psfFitSignaltoNoise=68.164107534076919)
    10 loops, best of 3: 48 ms per loop



```python
result = genDipoleAndFitIt_ipDiffim(z=z, w=51, h=51, xc=25., yc=25., psfWidth=2., separation=2., rotAngle=0.,
                              flux=2500., noise=1., verbose=False, display=False)
print result

%timeit result = genDipoleAndFitIt_ipDiffim(z=z, w=51, h=51, xc=25., yc=25., psfWidth=2., separation=2., rotAngle=0., \
                              flux=2500., noise=1., verbose=False, display=False)
```

    resultsOutput(inputCentroidX=25.0, inputCentroidY=25.0, inputSeparation=2.0, inputRotation=0.0, inputFlux=2500.0, inputPosCentroidX=26.0, inputPosCentroidY=25.0, inputNegCentroidX=24.0, inputNegCentroidY=25.0, psfFitPosCentroidX=25.25330988529868, psfFitPosCentroidY=24.4272670679188, psfFitNegCentroidX=24.5756094153161, psfFitNegCentroidY=24.754402837429826, psfFitPosFlux=5575.402785668327, psfFitNegFlux=-5394.597733769506, psfFitCentroidX=24.914459650307393, psfFitCentroidY=24.590834952674314, psfFitOrientation=2.02052 rad, psfFitSignaltoNoise=2.9700320829657865)
    10 loops, best of 3: 112 ms per loop



```python
def genDipoleAndFitBothWays(z=z, w=51, h=51, xc=25., yc=25., psfWidth=2., separation=2., rotAngle=0.,
                              flux=2500., noise=1., rel_weight=0.1, verbose=False, display=False):
    if z is None:
        _, _, z = genDipole(w=w, h=h, xc=xc, yc=yc, psfWidth=psfWidth, separation=separation, rotAngle=rotAngle,
                            flux=flux, noise=noise, display=display)

    result1 = genDipoleAndFitIt(z=z, w=w, h=h, xc=xc, yc=yc, psfWidth=psfWidth, separation=separation, rotAngle=rotAngle,
                              flux=flux, noise=noise, rel_weight=rel_weight, verbose=verbose, display=display)
    
    result2 = genDipoleAndFitIt_ipDiffim(z=z, w=w, h=h, xc=xc, yc=yc, psfWidth=psfWidth, separation=separation, rotAngle=rotAngle,
                              flux=flux, noise=noise, verbose=verbose, display=display)
    
    return {'old': result2, 'new': result1}
```


```python
result = genDipoleAndFitBothWays(z=None, w=51, h=51, xc=25., yc=25., psfWidth=2., separation=2., rotAngle=0.,
                                flux=2500., noise=1., rel_weight=0.1, verbose=False, display=True)
print result['old']
print result['new']
```

    resultsOutput(inputCentroidX=25.0, inputCentroidY=25.0, inputSeparation=2.0, inputRotation=0.0, inputFlux=2500.0, inputPosCentroidX=26.0, inputPosCentroidY=25.0, inputNegCentroidX=24.0, inputNegCentroidY=25.0, psfFitPosCentroidX=25.000062960534137, psfFitPosCentroidY=24.880924212823885, psfFitNegCentroidX=24.64060537890642, psfFitNegCentroidY=24.902057521729674, psfFitPosFlux=11189.738162858966, psfFitNegFlux=-11380.18235826772, psfFitCentroidX=24.82033416972028, psfFitCentroidY=24.89149086727678, psfFitOrientation=1.62952 rad, psfFitSignaltoNoise=137.04693526911819)
    resultsOutput(inputCentroidX=25.0, inputCentroidY=25.0, inputSeparation=2.0, inputRotation=0.0, inputFlux=2500.0, inputPosCentroidX=26.0, inputPosCentroidY=25.0, inputNegCentroidX=24.0, inputNegCentroidY=25.0, psfFitPosCentroidX=25.763984037916984, psfFitPosCentroidY=25.027119773894594, psfFitNegCentroidX=23.947915844023392, psfFitNegCentroidY=24.989552645283393, psfFitPosFlux=2736.1064603010846, psfFitNegFlux=-2877.2898359388623, psfFitCentroidX=24.855949940970188, psfFitCentroidY=25.008336209588993, psfFitOrientation=1.1850496516791906, psfFitSignaltoNoise=69.681893944068392)



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_14_1.png)



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_14_2.png)



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_14_3.png)



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_14_4.png)


### First test dipoles of varying separation (same orientation, same flux)


```python
varNames = genDipoleAndFitBothWays.__code__.co_varnames[:genDipoleAndFitBothWays.__code__.co_argcount]
varTuple = namedtuple("varTuple", varNames)

#orientations = np.arange(0.0, 360.0, 36.0)
separations = np.arange(0.2, 5.0, 0.2)
n_reps = 100

inputs = [varTuple(z=None, w=51, h=51, xc=25., yc=25., psfWidth=2.0, separation=sep, rotAngle=0., flux=3000., 
                   noise=1., rel_weight=0.05, verbose=False, display=False) for i in xrange(n_reps) for sep in separations]
print len(inputs)

def processInput(i):
    #print i.separation #, i.rotAngle
    output = genDipoleAndFitBothWays(z=i.z, w=i.w, h=i.h, xc=i.xc, yc=i.yc, psfWidth=i.psfWidth, 
                                     separation=i.separation, rotAngle=i.rotAngle, flux=i.flux, noise=i.noise, 
                                     rel_weight=i.rel_weight, verbose=False, display=False)
    output['new'] = output['new']._asdict()
    output['old'] = output['old']._asdict()
    return output

num_cores = multiprocessing.cpu_count() / 2
results = Parallel(n_jobs=num_cores)(delayed(processInput)(i) for i in inputs)
```

    2400



```python
matplotlib.rcParams['figure.figsize'] = (12.0, 6.0)
fig, axes = plt.subplots(nrows=1, ncols=2)

df = pd.DataFrame([res['new'] for res in results])
tmp_df = df.groupby('inputSeparation').mean()
tmp_df['inputSeparation'] = tmp_df.index.values
tmp_df2 = df.groupby('inputSeparation').std() * 1.
ax = tmp_df.plot(x='inputSeparation', y='psfFitPosCentroidX', kind='scatter', yerr=tmp_df2['psfFitPosCentroidX'], color='blue', label='pos', ax=axes[0])
tmp_df.plot(x='inputSeparation', y='psfFitNegCentroidX', kind='scatter', yerr=tmp_df2['psfFitNegCentroidX'], color='red', label='neg', ax=ax)

df = pd.DataFrame([res['old'] for res in results])
tmp_df = df.groupby('inputSeparation').mean()
tmp_df['inputSeparation'] = tmp_df.index.values
tmp_df2 = df.groupby('inputSeparation').std() * 1.
ax = tmp_df.plot(x='inputSeparation', y='psfFitPosCentroidX', kind='scatter', yerr=tmp_df2['psfFitPosCentroidX'], color='blue', label='pos', ax=axes[1])
tmp_df.plot(x='inputSeparation', y='psfFitNegCentroidX', kind='scatter', yerr=tmp_df2['psfFitNegCentroidX'], color='red', label='neg', ax=ax)

axes[0].set_title('New')
axes[0].set_ylim([22,28])
axes[1].set_title('Old')
axes[0].set_ylim([22,28])
```




    (22, 28)



    /Users/dreiss/miniconda/lib/python2.7/site-packages/matplotlib/collections.py:590: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison
      if self._edgecolors == str('face'):



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_17_2.png)



```python
matplotlib.rcParams['figure.figsize'] = (18.0, 6.0)
fig, axes = plt.subplots(nrows=1, ncols=2)

df = pd.DataFrame([res['new'] for res in results])
sns.violinplot(x="inputSeparation", y="psfFitOrientation", data=df, inner="quart", cut=True, linewidth=0.1, bw=0.2, ax=axes[0])
sns.despine(left=True)

df = pd.DataFrame([res['old'] for res in results])
df['angle'] = pd.Series([float(i * 180. / np.pi) for i in df.psfFitOrientation])
sns.violinplot(x="inputSeparation", y="angle", data=df, inner="quart", cut=True, linewidth=0.1, bw=0.2, ax=axes[1])
sns.despine(left=True)

axes[0].set_title('New')
axes[0].set_ylim([-20,20])
axes[1].set_title('Old')
axes[1].set_ylim([70,110])
```




    (70, 110)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_18_1.png)



```python
fig, axes = plt.subplots(nrows=1, ncols=2)

df = pd.DataFrame([res['new'] for res in results])
df['diffCentroidPos'] = df.psfFitPosCentroidX - df.inputPosCentroidX
df['diffCentroidNeg'] = df.psfFitNegCentroidX - df.inputNegCentroidX
df['inputSeparation2'] = df.inputSeparation + 0.05
tmp_df = df.groupby('inputSeparation').mean()
tmp_df['inputSeparation'] = tmp_df.index.values
tmp_df2 = df.groupby('inputSeparation').std() * 1.
ax = tmp_df.plot(x='inputSeparation', y='diffCentroidPos', kind='scatter', yerr=tmp_df2['diffCentroidPos'], color='blue', label='pos', ax=axes[0])
tmp_df.plot(x='inputSeparation2', y='diffCentroidNeg', kind='scatter', yerr=tmp_df2['diffCentroidNeg'], color='red', label='neg', ax=ax)

df = pd.DataFrame([res['old'] for res in results])
df['diffCentroidPos'] = df.psfFitPosCentroidX - df.inputPosCentroidX
df['diffCentroidNeg'] = df.psfFitNegCentroidX - df.inputNegCentroidX
df['inputSeparation2'] = df.inputSeparation + 0.05
tmp_df = df.groupby('inputSeparation').mean()
tmp_df['inputSeparation'] = tmp_df.index.values
tmp_df2 = df.groupby('inputSeparation').std() * 1.
ax = tmp_df.plot(x='inputSeparation', y='diffCentroidPos', kind='scatter', yerr=tmp_df2['diffCentroidPos'], color='blue', label='pos', ax=axes[1])
tmp_df.plot(x='inputSeparation2', y='diffCentroidNeg', kind='scatter', yerr=tmp_df2['diffCentroidNeg'], color='red', label='neg', ax=ax)

axes[0].set_title('New')
axes[0].set_ylim([-2.2,2.2]); axes[0].set_xlim([0,5])
axes[1].set_title('Old')
axes[1].set_ylim([-2.2,2.2]); axes[1].set_xlim([0,5])
```




    (0, 5)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_19_1.png)



```python
fig, axes = plt.subplots(nrows=1, ncols=2)

df = pd.DataFrame([res['new'] for res in results])
tmp_df = df.groupby('inputSeparation').mean()
tmp_df['inputSeparation'] = tmp_df.index.values
tmp_df2 = df.groupby('inputSeparation').std() * 1.
ax = tmp_df.plot(x='inputSeparation', y='psfFitPosFlux', kind='scatter', yerr=tmp_df2['psfFitPosFlux'], color='blue', label='pos', ax=axes[0])
tmp_df.plot(x='inputSeparation', y='psfFitNegFlux', kind='scatter', yerr=tmp_df2['psfFitNegFlux'], color='red', label='neg', ax=ax)

df = pd.DataFrame([res['old'] for res in results])
tmp_df = df.groupby('inputSeparation').mean()
tmp_df['inputSeparation'] = tmp_df.index.values
tmp_df2 = df.groupby('inputSeparation').std() * 1.
ax = tmp_df.plot(x='inputSeparation', y='psfFitPosFlux', kind='scatter', yerr=tmp_df2['psfFitPosFlux'], color='blue', label='pos', ax=axes[1])
tmp_df.plot(x='inputSeparation', y='psfFitNegFlux', kind='scatter', yerr=tmp_df2['psfFitNegFlux'], color='red', label='neg', ax=ax)

axes[0].set_title('New')
axes[0].set_ylim([-8000,8000])
axes[1].set_title('Old')
axes[1].set_ylim([-8000,8000])
```




    (-8000, 8000)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_20_1.png)



```python
matplotlib.rcParams['figure.figsize'] = (18.0, 6.0)
fig, axes = plt.subplots(nrows=1, ncols=2)

df1 = pd.DataFrame([res['new'] for res in results])
df2 = df1.copy()
df1['psfFitFlux'] = df1.psfFitPosFlux   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['psfFitFlux'] = -df2.psfFitNegFlux   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputSeparation", y="psfFitFlux", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, linewidth=0.1, bw=0.2, ax=axes[0])
sns.despine(left=True)

df1 = pd.DataFrame([res['old'] for res in results])
df2 = df1.copy()
df1['psfFitFlux'] = df1.psfFitPosFlux   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df1.loc[(df1.psfFitFlux > 30000.), 'psfFitFlux'] = 30000.
df2['psfFitFlux'] = -df2.psfFitNegFlux   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
df2.loc[(df2.psfFitFlux > 30000.), 'psfFitFlux'] = 30000.
sns.violinplot(x="inputSeparation", y="psfFitFlux", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, linewidth=0.1, bw=0.2, ax=axes[1])
sns.despine(left=True)

axes[0].set_title('New')
axes[0].set_ylim([-1000,15000])
axes[1].set_title('Old')
axes[1].set_ylim([-1000,15000])
```




    (-1000, 15000)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_21_1.png)


Try it again, this time setting different orientations as well. Next time we'll also test it as a function of scaling (source flux).

## Different orientations AND separations


```python
varNames = genDipoleAndFitBothWays.__code__.co_varnames[:genDipoleAndFitBothWays.__code__.co_argcount]
varTuple = namedtuple("varTuple", varNames)

orientations = np.arange(0.0, 360.0, 36.0)
separations = np.arange(0.2, 5.0, 0.2)
n_reps = 10

inputs = [varTuple(z=None, w=51, h=51, xc=25., yc=25., psfWidth=2.0, separation=sep, rotAngle=rot, 
                    flux=3000., noise=1., rel_weight=0.05, verbose=False, display=False) 
          for i in xrange(n_reps) for rot in orientations for sep in separations]
print len(inputs)

def processInput(i):
    output = genDipoleAndFitBothWays(z=i.z, w=i.w, h=i.h, xc=i.xc, yc=i.yc, psfWidth=i.psfWidth, 
                                     separation=i.separation, rotAngle=i.rotAngle, flux=i.flux, 
                                     rel_weight=i.rel_weight, noise=i.noise, verbose=False, display=False)
    output['new'] = output['new']._asdict()
    output['old'] = output['old']._asdict()
    return output

num_cores = multiprocessing.cpu_count() / 2
results2 = Parallel(n_jobs=num_cores)(delayed(processInput)(i) for i in inputs)
```

    2400



```python
fig, axes = plt.subplots(nrows=1, ncols=2)

df = pd.DataFrame([res['new'] for res in results2])
df['rmsCentroidPos'] = np.sqrt((df.inputPosCentroidX - df.psfFitPosCentroidX)**2. + \
                               (df.inputPosCentroidY - df.psfFitPosCentroidY)**2.)

df['rmsCentroidNeg'] = np.sqrt((df.inputNegCentroidX - df.psfFitNegCentroidX)**2. + \
                               (df.inputNegCentroidY - df.psfFitNegCentroidY)**2.)
df['inputSeparation2'] = df.inputSeparation + 0.05
tmp_df = df.groupby('inputSeparation').median()
tmp_df['inputSeparation'] = tmp_df.index.values
tmp_df2 = df.groupby('inputSeparation').mad() * 1.
ax = tmp_df.plot(x='inputSeparation', y='rmsCentroidPos', kind='scatter', yerr=tmp_df2['rmsCentroidPos'], color='blue', label='pos', ax=axes[0])
tmp_df.plot(x='inputSeparation2', y='rmsCentroidNeg', kind='scatter', yerr=tmp_df2['rmsCentroidNeg'], color='red', label='neg', ax=ax)

df = pd.DataFrame([res['old'] for res in results2])
df['rmsCentroidPos'] = np.sqrt((df.inputPosCentroidX - df.psfFitPosCentroidX)**2. + \
                               (df.inputPosCentroidY - df.psfFitPosCentroidY)**2.)
df['rmsCentroidNeg'] = np.sqrt((df.inputNegCentroidX - df.psfFitNegCentroidX)**2. + \
                               (df.inputNegCentroidY - df.psfFitNegCentroidY)**2.)
df['inputSeparation2'] = df.inputSeparation + 0.05
tmp_df = df.groupby('inputSeparation').median()
tmp_df['inputSeparation'] = tmp_df.index.values
tmp_df2 = df.groupby('inputSeparation').mad() * 1.
ax = tmp_df.plot(x='inputSeparation', y='rmsCentroidPos', kind='scatter', yerr=tmp_df2['rmsCentroidPos'], color='blue', label='pos', ax=axes[1])
tmp_df.plot(x='inputSeparation2', y='rmsCentroidNeg', kind='scatter', yerr=tmp_df2['rmsCentroidNeg'], color='red', label='neg', ax=ax)

axes[0].set_title('New')
axes[0].set_ylim([0.,1.8]); axes[0].set_xlim([0, 5])
axes[1].set_title('Old')
axes[1].set_ylim([0.,1.8]); axes[1].set_xlim([0, 5])
```




    (0, 5)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_24_1.png)



```python
matplotlib.rcParams['figure.figsize'] = (18.0, 6.0)
fig, axes = plt.subplots(nrows=1, ncols=2)

df1 = pd.DataFrame([res['new'] for res in results2])
df2 = df1.copy()
df1['rmsCentroid'] = np.sqrt((df1.inputPosCentroidX - df1.psfFitPosCentroidX)**2. + \
                               (df1.inputPosCentroidY - df1.psfFitPosCentroidY)**2.)   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['rmsCentroid'] = np.sqrt((df2.inputNegCentroidX - df2.psfFitNegCentroidX)**2. + \
                               (df2.inputNegCentroidY - df2.psfFitNegCentroidY)**2.)   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputSeparation", y="rmsCentroid", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, linewidth=0.3, bw=0.2, ax=axes[0])
sns.despine(left=True)

df1 = pd.DataFrame([res['old'] for res in results2])
df2 = df1.copy()
df1['rmsCentroid'] = np.sqrt((df1.inputPosCentroidX - df1.psfFitPosCentroidX)**2. + \
                               (df1.inputPosCentroidY - df1.psfFitPosCentroidY)**2.)   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['rmsCentroid'] = np.sqrt((df2.inputNegCentroidX - df2.psfFitNegCentroidX)**2. + \
                               (df2.inputNegCentroidY - df2.psfFitNegCentroidY)**2.)   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputSeparation", y="rmsCentroid", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, linewidth=0.3, bw=0.2, ax=axes[1])
sns.despine(left=True)

axes[0].set_title('New')
axes[0].set_ylim([-0.1,2.0])
axes[1].set_title('Old')
axes[1].set_ylim([-0.1,2.0])
```




    (-0.1, 2.0)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_25_1.png)



```python
matplotlib.rcParams['figure.figsize'] = (18.0, 6.0)
fig, axes = plt.subplots(nrows=1, ncols=2)

df1 = pd.DataFrame([res['new'] for res in results2])
df2 = df1.copy()
df1['psfFitFlux'] = df1.psfFitPosFlux   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['psfFitFlux'] = -df2.psfFitNegFlux   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputSeparation", y="psfFitFlux", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, linewidth=0.3, bw=0.2, ax=axes[0])
sns.despine(left=True)

df1 = pd.DataFrame([res['old'] for res in results2])
df2 = df1.copy()
df1['psfFitFlux'] = df1.psfFitPosFlux   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df1.loc[(df1.psfFitFlux > 30000.), 'psfFitFlux'] = 30000.
df2['psfFitFlux'] = -df2.psfFitNegFlux   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
df2.loc[(df2.psfFitFlux > 30000.), 'psfFitFlux'] = 30000.
sns.violinplot(x="inputSeparation", y="psfFitFlux", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, linewidth=0.3, bw=0.2, ax=axes[1])
sns.despine(left=True)

axes[0].set_title('New')
axes[0].set_ylim([-1000,15000])
axes[1].set_title('Old')
axes[1].set_ylim([-1000,15000])
```




    (-1000, 15000)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_26_1.png)


## Different dipole fluxes (signal-to-noise) AND orientations AND separations


```python
varNames = genDipoleAndFitBothWays.__code__.co_varnames[:genDipoleAndFitBothWays.__code__.co_argcount]
varTuple = namedtuple("varTuple", varNames)

orientations = np.arange(0.0, 360.0, 36.0)
separations = np.arange(0.2, 5.0, 0.2)
fluxes = np.arange(250., 6000., 250.)
n_reps = 2 ## if I do more than 2 the code doesn't seem to want to exit the cell, even after it completes.

inputs = [varTuple(z=None, w=51, h=51, xc=25., yc=25., psfWidth=2.0, separation=sep, rotAngle=rot, 
                    flux=flux, noise=1., rel_weight=0.05, verbose=False, display=False) 
                for i in xrange(n_reps) for flux in fluxes for rot in orientations for sep in separations]
print len(inputs)

def processInput(i):
    #print i.flux, i.separation, i.rotAngle
    output = genDipoleAndFitBothWays(z=i.z, w=i.w, h=i.h, xc=i.xc, yc=i.yc, psfWidth=i.psfWidth, 
                                     separation=i.separation, rotAngle=i.rotAngle, flux=i.flux, 
                                     noise=i.noise, rel_weight=i.rel_weight, verbose=False, display=False)
    output['new'] = output['new']._asdict()
    output['old'] = output['old']._asdict()
    return output
 
num_cores = multiprocessing.cpu_count() / 2
#results3 = [processInput(i) for i in inputs]
results3 = Parallel(n_jobs=num_cores)(delayed(processInput)(i) for i in inputs)
```

    11040



```python
## NOT RUN:
if False:
    import cPickle as pickle
    import gzip
    pickle.dump((results, results2, results3), gzip.GzipFile("results_8.p.gz", "wb"))
```


```python
matplotlib.rcParams['figure.figsize'] = (18.0, 6.0)
fig, axes = plt.subplots(nrows=1, ncols=2)

df1 = pd.DataFrame([res['new'] for res in results3])
df2 = df1.copy()
df1['rmsCentroid'] = np.sqrt((df1.inputPosCentroidX - df1.psfFitPosCentroidX)**2. + \
                               (df1.inputPosCentroidY - df1.psfFitPosCentroidY)**2.)   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['rmsCentroid'] = np.sqrt((df2.inputNegCentroidX - df2.psfFitNegCentroidX)**2. + \
                               (df2.inputNegCentroidY - df2.psfFitNegCentroidY)**2.)   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputSeparation", y="rmsCentroid", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, linewidth=0.1, bw=0.1, ax=axes[0])
sns.despine(left=True)

df1 = pd.DataFrame([res['old'] for res in results3])
df2 = df1.copy()
df1['rmsCentroid'] = np.sqrt((df1.inputPosCentroidX - df1.psfFitPosCentroidX)**2. + \
                               (df1.inputPosCentroidY - df1.psfFitPosCentroidY)**2.)   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['rmsCentroid'] = np.sqrt((df2.inputNegCentroidX - df2.psfFitNegCentroidX)**2. + \
                               (df2.inputNegCentroidY - df2.psfFitNegCentroidY)**2.)   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputSeparation", y="rmsCentroid", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, linewidth=0.1, bw=0.1, ax=axes[1])
sns.despine(left=True)

axes[0].set_title('New')
axes[0].set_ylim([-0.05,1.5])
axes[1].set_title('Old')
axes[1].set_ylim([-0.05,1.5])
```




    (-0.05, 1.5)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_30_1.png)



```python
##### matplotlib.rcParams['figure.figsize'] = (18.0, 6.0)
fig, axes = plt.subplots(nrows=1, ncols=2)

df1 = pd.DataFrame([res['new'] for res in results3])
#df1 = df1.loc[(df1.inputFlux == 5000.)]
df2 = df1.copy()
df1['psfFitFlux'] = df1.psfFitPosFlux   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['psfFitFlux'] = -df2.psfFitNegFlux   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputSeparation", y="psfFitFlux", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, bw=0.25, linewidth=0.1, ax=axes[0])
sns.despine(left=True)

df1 = pd.DataFrame([res['old'] for res in results3])
#df1 = df1.loc[(df1.inputFlux == 5000.)]
df2 = df1.copy()
df1['psfFitFlux'] = df1.psfFitPosFlux   # positive
#df1.loc[(df1.psfFitFlux > 30000.), 'psfFitFlux'] = 30000.
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['psfFitFlux'] = -df2.psfFitNegFlux   # negative
#df2.loc[(df2.psfFitFlux > 30000.), 'psfFitFlux'] = 30000.
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputSeparation", y="psfFitFlux", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, bw=0.25, linewidth=0.1, ax=axes[1])
sns.despine(left=True)

axes[0].set_title('New')
axes[0].set_ylim([-1000,15000])
axes[1].set_title('Old')
axes[1].set_ylim([-1000,15000])
```




    (-1000, 15000)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_31_1.png)



```python
matplotlib.rcParams['figure.figsize'] = (18.0, 6.0)
fig, axes = plt.subplots(nrows=1, ncols=2)

df1 = pd.DataFrame([res['new'] for res in results3])
df2 = df1.copy()
df1['psfFitFlux'] = df1.psfFitPosFlux   # positive
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['psfFitFlux'] = -df2.psfFitNegFlux   # negative
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputFlux", y="psfFitFlux", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, bw=0.1, linewidth=0.1, ax=axes[0])
sns.despine(left=True)

df1 = pd.DataFrame([res['old'] for res in results3])
df2 = df1.copy()
df1['psfFitFlux'] = df1.psfFitPosFlux   # positive
#df1.loc[(df1.psfFitFlux > 30000.), 'psfFitFlux'] = 30000.
df1['posOrNeg'] = np.repeat('pos', df1.shape[0])
df2['psfFitFlux'] = -df2.psfFitNegFlux   # negative
#df2.loc[(df2.psfFitFlux > 30000.), 'psfFitFlux'] = 30000.
df2['posOrNeg'] = np.repeat('neg', df2.shape[0])
sns.violinplot(x="inputFlux", y="psfFitFlux", hue="posOrNeg", data=df1.append(df2), split=True,
               inner="quart", palette={"pos": "b", "neg": "y"}, cut=True, bw=0.1, linewidth=0.1, ax=axes[1])
sns.despine(left=True)

axes[0].set_title('New')
axes[0].set_ylim([0,7000])
axes[1].set_title('Old')
axes[1].set_ylim([0,7000])
```




    (0, 7000)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_32_1.png)



```python
df1 = pd.DataFrame([res['new'] for res in results3])
df2 = pd.DataFrame([res['old'] for res in results3])
df = pd.DataFrame({'new': df1['psfFitPosFlux'], 'old': df2['psfFitPosFlux'], 'fl': df1['inputFlux']})
df = df[(df['new'] != np.inf) & (df['old'] != np.inf)] # & (df['sn1'] < 30000.) & (df['sn2'] < 30000.)]
ax = df.plot(x='new', y='old', kind='scatter', c=df['fl']/df['fl'].max(), s=5.)
ax.set_xlim([-500,6500])
ax.set_ylim([-500,14000])
```




    (-500, 14000)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_33_1.png)



```python
df = pd.DataFrame([res['new'] for res in results3])
df['newOrOld'] = np.repeat('new', df.shape[0])
df['log10psfFitSignalToNoise'] = np.log10(df['psfFitSignaltoNoise'])
df = df[(df.log10psfFitSignalToNoise != np.inf) & (df.log10psfFitSignalToNoise != np.nan) & (df.log10psfFitSignalToNoise < 8000.)]

df2 = pd.DataFrame([res['old'] for res in results3])
df2['newOrOld'] = np.repeat('old', df2.shape[0])
df2['log10psfFitSignalToNoise'] = np.log10(df2['psfFitSignaltoNoise'])
df2 = df2[(np.abs(df2.log10psfFitSignalToNoise) != np.inf) & (df2.log10psfFitSignalToNoise != np.nan) & (df2.log10psfFitSignalToNoise < 8000.)]

df = df.append(df2)

matplotlib.rcParams['figure.figsize'] = (18.0, 6.0)
#fig, axes = plt.subplots(nrows=1, ncols=2)
fig = plt.figure()
ax = fig.add_subplot(111)

sns.violinplot(x="inputFlux", y="log10psfFitSignalToNoise", hue="newOrOld", data=df, split=True,
               inner="quart", palette={"new": "b", "old": "y"}, cutoff=True, bw=0.2, axis=ax)
sns.despine(left=True)
ax.set_ylim([-0.5,3.])
```




    (-0.5, 3.0)




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_34_1.png)


## Investigate error contours by including (or not) the pre-subtracted image planes in the fit


```python
verbose = True
x, y, z = genDipole(w=51, h=51, xc=25., yc=25., psfWidth=2., separation=0.4, rotAngle=324., 
                flux=3000., noise=1., display=True)
verbose = False

result0 = fitDipole(z, psfWidth=2., rel_weight=0., verbose=False, display=False, tol=1e-4)
result1 = fitDipole(z, psfWidth=2., rel_weight=0.05, verbose=False, display=False, tol=1e-4)
```

    SNR: 3000.0 1.0 2601.0 33.1254183836
    SNR: 3000.0 1.0 2601.0 33.1254183836



![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_36_1.png)


### Plot confidence intervals...

see https://lmfit.github.io/lmfit-py/confidence.html

First, don't include pre-subtracted data (weight=0)


```python
## hide warnings for this fit.
import warnings
warnings.filterwarnings('ignore')

ci, trace = lmfit.conf_interval(result0, result0, sigmas=[0.68,0.95],
                                trace=True, verbose=False)
lmfit.printfuncs.report_ci(ci)

cx, cy, grid = lmfit.conf_interval2d(result0, result0, 'xcenPos','flux', 30, 30)
plt.contourf(cx, cy, grid, np.linspace(0,1,11))
plt.xlabel('xcenPos')
plt.ylabel('flux')
plt.colorbar()
```

                95.00%    68.00%    _BEST_    68.00%    95.00%
     xcenPos:  -0.45084  -0.13622  26.00597      +inf      +inf
     ycenPos:      -inf      -inf  24.92471  +0.09286  +0.23961
     xcenNeg:      -inf      -inf  24.19473  +0.13704  +0.41636
     ycenNeg:  -0.22979  -0.08504  25.88096      +inf      +inf
     flux   :-197.45730-157.59758 646.89478+120.67571+542.54990
     fluxNeg:-198.73550-158.57475 679.43200+120.61883+534.08339





    <matplotlib.colorbar.Colorbar instance at 0x12d247ab8>




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_39_2.png)



```python
ci, trace = lmfit.conf_interval(result0, result0, sigmas=[0.68,0.95],
                                trace=True, verbose=False)
lmfit.printfuncs.report_ci(ci)

cx, cy, grid = lmfit.conf_interval2d(result0, result0, 'xcenPos','ycenPos', 30, 30)
plt.contourf(cx, cy, grid, np.linspace(0,1,11))
plt.xlabel('xcenPos')
plt.ylabel('ycenPos')
plt.colorbar()
```

                95.00%    68.00%    _BEST_    68.00%    95.00%
     xcenPos:  -0.45084  -0.13622  26.00597      +inf      +inf
     ycenPos:      -inf      -inf  24.92471  +0.09286  +0.23961
     xcenNeg:      -inf      -inf  24.19473  +0.13704  +0.41636
     ycenNeg:  -0.22979  -0.08504  25.88096      +inf      +inf
     flux   :-197.45730-157.59758 646.89478+120.67571+542.54990
     fluxNeg:-198.73550-158.57475 679.43200+120.61883+534.08339





    <matplotlib.colorbar.Colorbar instance at 0x12cdf73b0>




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_40_2.png)


Now, with the pre-subtraction data weighted at 5% of the subtracted data:


```python
ci, trace = lmfit.conf_interval(result1, result1, sigmas=[0.68,0.95],
                                trace=True, verbose=False)
lmfit.printfuncs.report_ci(ci)

cx, cy, grid = lmfit.conf_interval2d(result1, result1, 'xcenPos','flux', 30, 30)
plt.contourf(cx, cy, grid, np.linspace(0,1,11))
plt.xlabel('xcenPos')
plt.ylabel('flux')
plt.colorbar()
```

                95.00%    68.00%    _BEST_    68.00%    95.00%
     xcenPos:  -0.14001  -0.07073  24.92859  +0.07289  +0.14349
     ycenPos:  -0.13496  -0.06732  24.95365  +0.06733  +0.13601
     xcenNeg:  -0.14439  -0.07360  24.61542  +0.07595  +0.14959
     ycenNeg:  -0.13950  -0.07048  25.16059  +0.07186  +0.14104
     flux   :-270.03903-136.963903030.25897+137.26134+270.30662
     fluxNeg:-269.81911-136.803783002.05385+137.02030+269.85319





    <matplotlib.colorbar.Colorbar instance at 0x12d528098>




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_42_2.png)



```python
ci, trace = lmfit.conf_interval(result1, result1, sigmas=[0.68,0.95],
                                trace=True, verbose=False)
lmfit.printfuncs.report_ci(ci)

cx, cy, grid = lmfit.conf_interval2d(result1, result1, 'xcenPos','ycenPos', 30, 30)
plt.contourf(cx, cy, grid, np.linspace(0,1,11))
plt.xlabel('xcenPos')
plt.ylabel('ycenPos')
plt.colorbar()
```

                95.00%    68.00%    _BEST_    68.00%    95.00%
     xcenPos:  -0.08795  -0.04200  25.24468  +0.05332  +0.09897
     ycenPos:  -0.10236  -0.04763  25.23124  +0.07001  +0.12336
     xcenNeg:  -0.08842  -0.04228  24.86614  +0.05391  +0.09979
     ycenNeg:  -0.10975  -0.05204  25.42525  +0.07158  +0.12898
     flux   :-265.74029-137.344293018.03795+139.85529+268.36188
     fluxNeg:-266.28690-137.931873049.71981+139.06862+267.44260





    <matplotlib.colorbar.Colorbar instance at 0x12c0abfc8>




![png](8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_files/8b.%20include%20down-weighted%20pre-subtraction%20image%20%22planes%22%20to%20constrain%202-d%20dipole%20fit_43_2.png)



```python

```
